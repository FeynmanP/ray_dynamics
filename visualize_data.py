#!/usr/bin/env python3
# -*- coding: utf-8 -*-
__author__ = 'You Mengyu'

import os
import time

import matplotlib as mpl
import boundary_all
import pandas as pd
import numpy as np

import os_tools

"""
Visualize the data generated by ray_dynamics.py.
Change the style of plot as you like.
"""

import matplotlib.pyplot as plt


def get_filepaths(path, filename=''):
    """Get paths of all files in given directory."""
    filepaths = []
    for root, dirs, files in os.walk(path):
        for file in files:
            filepath = os.path.join(root, file)
            if filename in filepath:
                filepaths.append(filepath)
            # filepaths.append(filepath)

    return filepaths


def plot_traj(data_bdry, data_traj):
    plt.plot(data_bdry[:, 0], data_bdry[:, 1], c='black', linewidth=1.5)
    plt.plot(data_traj[:, 0], data_traj[:, 1], linewidth=0.3, c='black')

    plt.axis('equal')

    plt.show()


def plot_brik(data_brik):
    plt.plot(data_brik[:, 0], data_brik[:, 1], '.', c='black', markersize=0.5)

    plt.xlim([-np.pi - 0.001, np.pi + 0.001])
    plt.ylim([0, 1])

    plt.xlabel(r'phi')
    plt.ylabel(r'$\sin{\theta}$')

    plt.show()


def main_plot_full_brik():
    dirname1 = "/Users/youmy16/1_research/leaking_chaotic/download_from_server/D-shape_pars(1, 2)_full_brik_data_20221222_205850"
    dirname2 = "/Users/youmy16/1_research/leaking_chaotic/download_from_server/D-shape_pars(1, 2)_full_brik_data_20221222_205928"
    flag = 0
    index = 20
    data_plot = []

    for file in os.listdir(dirname1):
        data = np.load(os.path.join(dirname1, file))
        if len(data) > index+1:
            data_plot.append([data[index][0], data[index][1]])
        flag += 1
        print(flag)

    for file in os.listdir(dirname2):
        data = np.load(os.path.join(dirname2, file))
        # print(data[-1][2])
        if len(data) > index + 1:
            data_plot.append([data[index][0], data[index][1]])
        flag += 1
        print(flag)

    data = np.array(data_plot)

    plt.plot(data[:, 0], data[:, 1], '.', markersize=1, color='black')
    plt.xlim([0, 1])
    plt.ylim([0, 1])

    plt.show()


def main_plot_full_brik_partial_leak():
    dirname = "/Users/youmy16/1_research/leaking_chaotic/download_from_server/" \
              "221226_phase_partialLeak/4/D-shape_xyselected_full_brik_data_20221226_212817"
    flag = 0
    data_plot = []
    index = 0
    for file in os.listdir(dirname):
        data = np.load(os.path.join(dirname, file))
        # print(data[-1][2])
        if data[index][2] > 0:
            data_plot.append([data[index][0], data[index][1], data[index][2]])
    data = np.array(data_plot)
    x, y, z = data[:, 0], data[:, 1], data[:, 2]
    norm = mpl.colors.Normalize(z.min(), z.max())
    # plt.scatter(x, y, 1)

    plt.scatter(x, y, 0.1, z, norm=norm, cmap=mpl.cm.Greys)
    plt.xlim([0, 1])
    plt.ylim([-1, 1])

    plt.show()


def intensity():
    dirname = 'D_full_serve_230122'
    data_intensity = []
    for step in range(80):
        data = np.load(f'{dirname}/step{step}.npy')
        print(len(data))
        data_intensity.append([step, np.sum(data[:, 2])])

    data_plot = np.array(data_intensity)
    np.save('ray_data/intensity_develop.npy', data_plot)
    plt.plot(data_plot[:, 0], data_plot[:, 1], c='black')
    plt.yscale('log')
    plt.show()


def reform_data():
    aim_dir = 'D_full_serve'
    os.mkdir(aim_dir)
    # path_dir = '/Users/youmy16/1_research/leaking_chaotic/download_from_server/230113_phase_partialLeak/02'
    path_dir = '/Users/youmy16/1_research/leaking_chaotic/download_from_server/230113_phase_partialLeak/01'
    filepaths = get_filepaths(path_dir, 'brik.npy')
    for step in range(41):
        data = []
        flag = 0
        for file in filepaths:
            # print(file)
            data_temp = np.load(file, allow_pickle=True)
            print(data_temp[step])
            data.append(data_temp[step])
        print(data)
        np.save(f'./{aim_dir}/step{step}', np.array(data))
        # print(step)


def plot_reformed_data():
    dirpath = 'D_full_serve_230122'
    # dirpath = '/Volumes/Backup Plus/leakingChaos_data/ray_phase_n5/reformed_data'
    # dirpath = 'ray_data/upo6/reformed_data_r0.01'
    time_start = time.perf_counter()
    num = 1
    # fig, ax = plt.subplots(figsize=(8, 8))

    for step in range(40, 41):
        time_now = time.perf_counter()

        data = np.load(f'{dirpath}/step{step}.npy')
        plot_data = []
        z = data[:, 2]
        z_max = 1
        stardard = 1e100
        for i in range(len(data)):
            if z_max >= data[i][2] >= z_max/stardard:
                plot_data.append(data[i])

        x, y, z = np.array(plot_data)[:, 0], -np.array(plot_data)[:, 1], np.array(plot_data)[:, 2]
        # print(z)
        # print(z.max(), 1)
        norm = mpl.colors.LogNorm(1e-6, 1e-1)

        figname = f'/Users/youmy16/1_research/leaking_chaotic/imgs/ray_n5/full/step{step}'

        # ax.scatter(data[:, 0], -data[:, 1], 2)
        plt.scatter(x, y, 1, z, norm=norm, cmap=mpl.cm.jet, linewidths=0)
        plt.colorbar()
        plt.plot([0, 1], [1/5, 1/5], '--', c='black')
        plt.plot([0, 1], [-1/5, -1/5], '--', c='black')

        plt.xlim([0, 1])
        plt.ylim([-1, 1])
        # ax.legend()
        plt.show()
        # plt.savefig(figname)
        # plt.close()

        print(f'{num} / {79} jobs are finished.')
        os_tools.timer(time_start, time_now)
        # num += 1
    # ax.plot([0, 1], [1/5, 1/5], '--', c='black')
    # ax.plot([0, 1], [-1/5, -1/5], '--', c='black')
    # plt.show()


def plot_stable_manifold():
    step_choose = 15
    data0 = np.load('D_full_serve_230122/step0.npy')

    data_step = np.load(f'D_full_serve_230122/step{step_choose}.npy')
    # norm = mpl.colors.Normalize(10e-3, 1)

    data_stable = []
    data_unstable = []

    for i in range(len(data_step)):
        if data_step[i][2] >= 10e-3:
            data_stable.append(data0[i])
            data_unstable.append(data_step[i])
    data_plot_stable = np.array(data_stable)
    data_plot_unstable = np.array(data_unstable)
    # plt.scatter(data_plot[:, 0], -data_plot[:, 1], 0.5, linewidths=0)
    norm = mpl.colors.LogNorm(data_plot_unstable[:, 2].min(), data_plot_unstable[:, 2].max())
    # plt.scatter(data_plot_unstable[:, 0], -data_plot_unstable[:, 1], 0.5, data_plot_unstable[:, 2],
    #             norm=norm, cmap=mpl.cm.jet, linewidths=0)
    plt.scatter(data_plot_stable[:, 0], -data_plot_stable[:, 1], 0.5, c='black', linewidths=0)
    plt.axis([0, 1, -1, 1])
    # plt.colorbar()
    plt.show()


def find_peridic_orbits():
    """Find periodic orbits and save them"""
    data_0 = np.load('D_full_serve_230122/step0.npy')
    x, y = data_0[:, 0], data_0[:, 1]
    time_start = time.perf_counter()

    for step in range(1, 22):
        time_last = time.perf_counter()
        data_save = []
        data_selected = np.load(f'D_full_serve_230122/step{step}.npy')
        x_selected, y_selected = data_selected[:, 0], data_selected[:, 1]
        data_difference = z = (x_selected - x) ** 2 + (y_selected - y) ** 2

        data_ndarray = np.array([x, y, z])
        a, b = data_ndarray.shape
        data_reshaped = data_ndarray.T

        # sort data_reshaped by difference
        data_sorted = data_reshaped[data_reshaped[:, 2].argsort()]
        for data in data_sorted[:1000]:
            if -0.999 < data[1] < -0.001 or 0.001 < data[1] < 0.999:
                data_save.append(data)
        data_save_ndarray = np.array(data_save[:40])
        np.savetxt(f'./ray_data/UPO/periodic{step}', data_save_ndarray)
        print(step)
        os_tools.timer(time_start, time_last)


def plot_upo():
    data_0 = np.load('D_full_serve_230122/step0.npy')
    x, y = data_0[:, 0], data_0[:, 1]
    step = 3
    data_selected = np.load(f'D_full_serve_230122/step{step}.npy')
    x_selected, y_selected = data_selected[:, 0], data_selected[:, 1]
    data_difference = z = (x_selected - x) ** 2 + (y_selected - y) ** 2
    data_ndarray = np.array([x, y, z])
    data_reshaped = data_ndarray.T
    data_sorted = data_reshaped[data_reshaped[:, 2].argsort()]

    norm = mpl.colors.Normalize(0, 4)

    num = 1000
    for i in range(num):
        if -0.999 < data_sorted[i][1] < -0.001 or 0.001 < data_sorted[i][1] < 0.999:
            # plt.scatter(x[:num], y[:num], 1, data_sorted[:num], norm=norm, cmap=mpl.cm.jet)
            plt.scatter(data_sorted[i][0], data_sorted[i][1], 5, c='black')

    plt.xlim([0, 1])
    plt.ylim([-1, 1])
    plt.show()


def visualize_upo():
    data = np.load('UPO_D/periodic3.npy')
    num = 20
    plt.scatter(data[:20][:, 0], data[:20][:, 1], 5, c='black')
    plt.axis([0, 1, -1, 1])

    plt.show()


def compute_far_field(step):
    """
    compute far-field pattern.
    """
    data_file = f'D_upo3_r001/step{step}.npy'
    data = np.load(data_file)
    n = 3.3
    bdry = boundary_all.D((1, 2))
    ffp = []
    for info in data:
        s, p, energy, phi, x, y = info[0], info[1], info[2], info[3], info[4], info[5]
        if -1/n <= p <= 1/n:
            bdry_norm_vetor = -bdry.normal_vector_bdry(x, y)  # point to outside cavity
            theta_incident = np.arcsin(p)

            # rotation theta is positive in CCW direction, however, incident angle is nagetive in CCW direction
            # in ray dynamic codes, so that we put a "-" in this matrix
            mat_rotation_theta = np.array([[np.cos(-theta_incident), -np.sin(-theta_incident)],
                                           [np.sin(-theta_incident), np.cos(-theta_incident)]])

            vector_incident = np.matrix.dot(mat_rotation_theta, bdry_norm_vetor)

            # t = sprt(1 - nin**2 * (1 - (n * i)**2)) * n + nin * (i - (n * i) * n)
            # n X t = nin/nout (n X i)
            vector_trans = np.sqrt(1 - n**2 * (1 - (np.dot(bdry_norm_vetor, vector_incident)**2))) * bdry_norm_vetor \
                           + n * (vector_incident - (np.dot(bdry_norm_vetor, vector_incident) * bdry_norm_vetor))
            energy_refrac = energy * (1 - bdry.partial_leak_TM(phi, abs(np.arcsin(p))))
            theta_ffp = np.arctan2(vector_trans[1], vector_trans[0])
            ffp.append([theta_ffp, energy_refrac])

    data_ffp = np.array(ffp)
    if len(data_ffp) != 0:
        data_ffp = data_ffp[data_ffp[:, 0].argsort()]
    save_dir = './ray_data/far_field_ray/ffp_ray_upo3_r001'
    os_tools.mkdir(save_dir)
    np.save(f'{save_dir}/step{step}.npy', data_ffp)


def compute_ffps():
    time_start = time.perf_counter()
    whole_step = 40

    for step in range(1, whole_step):
        time_last = time.perf_counter()
        compute_far_field(step)
        print(f'Finished {step} / {whole_step} jobs.')
        os_tools.timer(time_start, time_last=time_last)


def plot_far_field(step):
    # sort date by angle (column 2)
    upo_dir = 'ffp_ray_upo3_r002'
    data_dir = f'ray_data/{upo_dir}'
    data_ffp = np.load(f'{data_dir}/step{step}.npy')
    # print(len(data_ffp))
    # data_ffp[:, 1] /= normalized_const

    divide_num = 720
    divide = int(divide_num/2 - 1)  # change with divide number

    data_plot = [[-np.pi, 0]]
    index = 0
    # print(len(data_ffp),  data_ffp.shape)

    for point in data_ffp:
        label = np.linspace(-np.pi, np.pi, divide_num)[1:]
        if point[0] <= data_plot[-1][0]:
            data_plot[-1][1] += point[1]
        else:
            data_plot.append([label[index], point[1]])
            index += 1

    # ffp_ray_data = np.array(data_plot)[1:]
    ffp_ray_data = np.load('ray_data/far_field_ray/ffp_plot_data/divided720_step9.npy')[1:]
    normalize_const_ray = np.sum(ffp_ray_data[:, 1])
    # fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})
    fig, ax = plt.subplots(figsize=(12, 8))
    reorder_data_x = np.concatenate((ffp_ray_data[divide:][:, 0] * 180 / np.pi,
                                     ffp_ray_data[:divide][:, 0] * 180 / np.pi + 360))
    reorder_data_y = np.concatenate((ffp_ray_data[divide:][:, 1] / normalize_const_ray,
                                     ffp_ray_data[:divide][:, 1] / normalize_const_ray
                                     ))
    ax.plot(reorder_data_x, reorder_data_y, linewidth=1, c='black')
    ax.set_xlim([0, 360])
    ax.tick_params(axis='both', labelsize=20)
    # ax.set_rticks([])
    plt.show()



    # print(data)


def plot_ffp_steps():
    time_start = time.perf_counter()
    savedir = '/Users/youmy16/1_research/leaking_chaotic/imgs/ffp_ray/ffp_ray_upo3_r002'
    os_tools.mkdir(savedir)
    for step in range(1, 40):
        time_now = time.perf_counter()
        try:
            plot_far_field(step)
            plt.savefig(f'{savedir}/divided300_step{step}.png')
            plt.close()
            os_tools.timer(time_start, time_now)
        except Exception as err:
            print(err)
            continue


def test_refraction():
    bdry_norm_vetor = np.array([0, 1])
    n = 3.3
    p = 1/4
    theta_incident = np.arcsin(p)
    mat_rotation_theta = np.array([[np.cos(-theta_incident), -np.sin(-theta_incident)],
                                   [np.sin(-theta_incident), np.cos(-theta_incident)]])

    vector_incident = np.matrix.dot(mat_rotation_theta, bdry_norm_vetor)
    # vector_incident = np.array([1, 1])

    vector_trans = np.sqrt(1 - n ** 2 * (1 - (np.dot(bdry_norm_vetor, vector_incident) ** 2))) * bdry_norm_vetor \
                   + n * (vector_incident - (np.dot(bdry_norm_vetor, vector_incident) * bdry_norm_vetor))

    print(vector_incident, bdry_norm_vetor, vector_trans)
    data_plot = [[-vector_incident[0], 0, vector_trans[0]], [-vector_incident[1], 0, vector_trans[1]]]
    plt.plot(data_plot[0], data_plot[1], '-')
    plt.plot([0, bdry_norm_vetor[0]], [0, bdry_norm_vetor[1]])
    plt.show()


def plot_tailored_phase():
    dirpath = '/Volumes/Backup Plus/leakingChaos_data/230216_phase_tailored_width0.06'
    phase_data = np.load('D_full_serve_230122/step9.npy')

    fig, ax = plt.subplots(figsize=(8, 8))

    x, y, z = phase_data[:, 0], -phase_data[:, 1], phase_data[:, 2]
    norm = mpl.colors.LogNorm(z.min(), 1)
    ax.scatter(x, y, 1, z, norm=norm, cmap=mpl.cm.jet, linewidths=0)
    data = []
    for data_file in os_tools.get_filepaths(dirpath, '.npy'):
        data = np.load(data_file)
        print(len(data))
        print(data.shape)
        ax.scatter(data[:, 0, 0], -data[:, 0, 1], 1, c='black', linewidths=0)
    plt.axis([0, 1, -1, 1])
    plt.show()


def plot_upo_traj():
    correct_const = 15  # one for ray, for wave, use the constant r_wave / r_ray
    bdry = boundary_all.D((1, 2))
    bdry_data = np.array(bdry.bdry_data) * correct_const
    plt.plot(bdry_data[:, 0], bdry_data[:, 1], c='black')

    # choose traj_data
    p3 = np.loadtxt('UPO_D/p3_points') * correct_const
    p6 = np.loadtxt('UPO_D/p6_points') * correct_const
    plt.plot(p3[:, 4], p3[:, 5], linewidth=0.8)
    plt.plot(p6[:, 4], p6[:, 5], linewidth=0.8)

    # plot absorber
    # v1.0 can only plot and define a squre obsorber with lines paraller to x,y-axis.
    xmin, xmax = -0.76 * correct_const, -0.70 * correct_const
    ymin, ymax = -0.01 * correct_const, 0.01 * correct_const

    xmin, xmax = 8, 14
    ymin, ymax = -8, 8

    plt.fill([xmin, xmax, xmax, xmin], [ymax, ymax, ymin, ymin], c='black', label='absorber')

    plt.legend()

    plt.axis('scaled')
    plt.xlim([-2.5 * correct_const, 2.5 * correct_const])
    plt.ylim([-2.5 * correct_const, 2.5 * correct_const])
    plt.show()


def patition_of_absorber():
    R = 30
    S_tot = (2/3 * np.pi + np.sqrt(3)/4) * R**2
    S_a = 6 * 16
    p1 = S_a / S_tot

    alpha_a = 10
    alpha_L = 0.004
    p2 = (S_a * alpha_a + (S_tot - S_a) * alpha_L) / (S_tot * alpha_L)

    print(p1, p2)




def test():
    for i in zip([1, 2, 3], [1, 2, 3]):
        plt.scatter(i[0], i[1])
    plt.show()


def main():
    dirpath = './Mushroom_pars(10, 10, 5)_nsteps1000_20220713_180755'
    data_bdry = np.load(f'{dirpath}/boundary_data.npy')
    data_traj = np.load(f'{dirpath}/position_data.npy')
    data_brik = np.load(f'{dirpath}/brikhoff_data.npy')

    # plot_traj(data_bdry, data_traj)
    plot_brik(data_brik)


if __name__ == '__main__':
    # main()
    # main_plot_full_brik_partial_leak()
    # intensity()
    # main_plot_full_brik()
    # reform_data()
    # plot_reformed_data()
    # plot_stable_manifold()
    # find_peridic_orbits()
    # plot_upo()
    # visualize_upo()
    # compute_ffps()
    # plot_far_field(30)
    # plot_upo_traj()
    # test()
    # plot_ffp_steps()
    # plot_tailored_phase()
    patition_of_absorber()

